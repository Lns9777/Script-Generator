import os
from dotenv import load_dotenv
from typing import List
from langchain_core.prompts import PromptTemplate
from langchain.chat_models import init_chat_model
from langchain_core.tools import BaseTool
from langchain.tools import Tool
from langchain_core.runnables import Runnable
from langchain.agents import create_react_agent, AgentExecutor

# Load environment variables (e.g., GROQ_API_KEY or GOOGLE_API_KEY if needed)
load_dotenv()

class ReactSQLAgent:
    """
    A class-based ReAct SQL Agent that decides whether to generate DDL, DML, or DCL
    scripts based on a business requirement, using a configurable LLM provider.
    """
    def __init__(self,
                 model_name: str = 'llama3-8b-8192',
                 provider: str = 'groq',
                 temperature: float = 0.1):
        # Initialize the LLM with lower temperature for more consistent formatting
        self.llm = init_chat_model(
            model=model_name,
            model_provider=provider,
            temperature=temperature
        )

        # Fixed prompt template with strict ReAct format
        self.prompt_template = PromptTemplate(
            input_variables=["input", "tools", "tool_names", "agent_scratchpad"],
            template="""You are a senior database developer and expert SQL generator.

Your task is to analyze the user's business requirement and generate the appropriate SQL using the available tools.

You have access to the following tools:
{tools}

Use the following format EXACTLY - do not deviate from this format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
Thought: I now know the final answer
Final Answer: the final answer to the original input question

CRITICAL RULES:
1. You must use exactly ONE tool call per requirement
2. Wait for the Observation before providing the Final Answer
3. Do NOT provide the Final Answer until you receive an Observation
4. The Final Answer should contain only the SQL generated by the tool
5. Do NOT generate SQL yourself - only use the tools provided
6. After receiving the Observation, immediately provide the Final Answer

Begin!

Question: {input}
Thought: {agent_scratchpad}"""
        )

        # Build tools and agent
        self.tools = self._create_tools()
        self.agent = self._create_agent()
        self.executor = self._create_executor()

    def _call_llm(self, prompt: str) -> str:
        """Helper to send prompt to LLM and return raw text."""
        try:
            response = self.llm.invoke(prompt)
            return response.content
        except Exception as e:
            return f"Error calling LLM: {str(e)}"

    def ddl_tool(self, requirement: str) -> str:
        """Generates DDL statements such as CREATE TABLE, ALTER TABLE, DROP TABLE, with constraints."""
        prompt = f"""Generate DDL (Data Definition Language) statements for this requirement:

{requirement}

Rules:
- Return only clean, executable SQL DDL statements
- Include appropriate data types, constraints, and indexes
- Use proper naming conventions
- No explanations, just SQL

SQL:"""
        
        return self._call_llm(prompt)

    def dml_tool(self, requirement: str) -> str:
        """Generates DML statements such as INSERT, SELECT, UPDATE, DELETE with realistic examples."""
        prompt = f"""Generate DML (Data Manipulation Language) statements for this requirement:

{requirement}

Rules:
- Return only clean, executable SQL DML statements
- Include appropriate WHERE clauses and sample data
- Use proper syntax for your database system
- No explanations, just SQL

SQL:"""
        
        return self._call_llm(prompt)

    def dcl_tool(self, requirement: str) -> str:
        """Generates DCL statements such as GRANT and REVOKE to control access and roles."""
        prompt = f"""Generate DCL (Data Control Language) statements for this requirement:

{requirement}

Rules:
- Return only clean, executable SQL DCL statements
- Include appropriate permissions and roles
- Use proper syntax for user management
- No explanations, just SQL

SQL:"""
        
        return self._call_llm(prompt)

    def _create_tools(self) -> List[BaseTool]:
        """Wraps the tool methods into Tool objects with descriptions."""
        return [
            Tool.from_function(
                self.ddl_tool, 
                name="DDL_Tool", 
                description="Use this tool when you need to create, modify, or drop database objects like tables, indexes, or constraints. Use for CREATE TABLE, ALTER TABLE, DROP TABLE, CREATE INDEX, etc."
            ),
            Tool.from_function(
                self.dml_tool, 
                name="DML_Tool", 
                description="Use this tool when you need to manipulate data in existing tables. Use for INSERT, SELECT, UPDATE, DELETE operations and data querying."
            ),
            Tool.from_function(
                self.dcl_tool, 
                name="DCL_Tool", 
                description="Use this tool when you need to control access permissions and user roles. Use for GRANT, REVOKE, CREATE ROLE, and user management."
            ),
        ]

    def _create_agent(self) -> Runnable:
        """Creates a ReAct agent using the configured LLM and tools."""
        return create_react_agent(
            tools=self.tools,
            llm=self.llm,
            prompt=self.prompt_template
        )

    def _create_executor(self) -> AgentExecutor:
        """Wraps the agent and tools into an executor for running queries."""
        return AgentExecutor(
            agent=self.agent,
            tools=self.tools,
            verbose=True,
            handle_parsing_errors=True,
            max_iterations=3,  # Limit iterations to prevent loops
            return_intermediate_steps=True,
            max_execution_time=30  # 30 seconds timeout
        )

    def run(self, requirement: str) -> dict:
        """Run the agent executor on the provided requirement."""
        try:
            if not requirement or not requirement.strip():
                return {
                    "output": "Please provide a valid business requirement.",
                    "error": "Empty requirement"
                }
            
            # Clean the requirement to avoid confusion
            cleaned_requirement = requirement.strip()
            
            # For Streamlit compatibility, use a simpler approach without signal
            import threading
            
            result_container = {"result": None, "error": None}
            
            def execute_agent():
                try:
                    # Create a fresh executor for each run to avoid state issues
                    executor = AgentExecutor(
                        agent=self.agent,
                        tools=self.tools,
                        verbose=True,
                        handle_parsing_errors=True,
                        # max_iterations=5,  # Reduced to 2 to prevent loops
                        return_intermediate_steps=True,
                        # max_execution_time=25  # Slightly reduced timeout
                    )
                    
                    result_container["result"] = executor.invoke({"input": cleaned_requirement})
                except Exception as e:
                    result_container["error"] = str(e)
            
            # Start execution in a separate thread
            thread = threading.Thread(target=execute_agent)
            thread.daemon = True
            thread.start()
            
            # Wait for completion with timeout
            thread.join(timeout=30)
            
            if thread.is_alive():
                return {
                    "output": "Request timed out. Please try a simpler requirement.",
                    "error": "Timeout"
                }
            
            if result_container["error"]:
                return {
                    "output": f"Error processing requirement: {result_container['error']}",
                    "error": result_container["error"]
                }
            
            result = result_container["result"]
            
            # Process the result to extract the final answer
            if isinstance(result, dict) and "output" in result:
                # Clean up the output to remove any extra formatting
                output = result["output"]
                if isinstance(output, str):
                    # Remove any extra whitespace and formatting
                    output = output.strip()
                    # If the output contains multiple SQL blocks, clean it up
                    if "```" in output:
                        # Extract SQL from code blocks
                        import re
                        sql_matches = re.findall(r'```(?:sql)?\n?(.*?)\n?```', output, re.DOTALL)
                        if sql_matches:
                            output = sql_matches[-1].strip()  # Take the last SQL block
                
                return {
                    "output": output,
                    "intermediate_steps": result.get("intermediate_steps", [])
                }
            else:
                return {"output": str(result)}
                
        except Exception as e:
            return {
                "output": f"Error processing requirement: {str(e)}",
                "error": str(e)
            }

def test_agent():
    """Test function to verify agent behavior with a simple requirement."""
    print("=== Testing ReactSQLAgent ===")
    
    try:
        sql_agent = ReactSQLAgent()
        test_req = "I want to create an employee table with id, name, and salary."
        
        print(f"Testing with requirement: {test_req}")
        print("\nüîÑ Processing...")
        
        result = sql_agent.run(test_req)
        
        print("\n===== Test Result =====")
        if isinstance(result, dict):
            if "output" in result:
                print(f"Output: {result['output']}")
            if "error" in result and result["error"]:
                print(f"Error: {result['error']}")
            if "intermediate_steps" in result:
                print(f"Steps taken: {len(result['intermediate_steps'])}")
        else:
            print(f"Result: {result}")
            
    except Exception as e:
        print(f"Test failed with error: {str(e)}")

def main():
    """Main function to demonstrate usage."""
    try:
        print("=== ReactSQLAgent - SQL Generator ===")
        print("This tool generates DDL, DML, or DCL SQL statements based on business requirements.")
        print("Type 'quit' or 'exit' to stop.\n")
        
        sql_agent = ReactSQLAgent()
        
        while True:
            try:
                req = input("Enter your business requirement:\n> ").strip()
                
                if req.lower() in ['quit', 'exit', 'q']:
                    print("Goodbye!")
                    break
                
                if not req:
                    print("Please enter a valid requirement.\n")
                    continue
                
                print("\nüîÑ Processing your request...")
                result = sql_agent.run(req)
                
                print("\n===== Generated SQL =====")
                if isinstance(result, dict):
                    if "output" in result:
                        print(result["output"])
                    if "error" in result and result["error"]:
                        print(f"\n‚ö†Ô∏è  Error: {result['error']}")
                else:
                    print(result)
                
                print("\n" + "="*50 + "\n")
                
            except KeyboardInterrupt:
                print("\n\nOperation cancelled by user. Goodbye!")
                break
            except Exception as e:
                print(f"\n‚ùå An error occurred: {str(e)}")
                print("Please try again.\n")
                
    except Exception as e:
        print(f"‚ùå Failed to initialize ReactSQLAgent: {str(e)}")
        print("Please check your environment variables and dependencies.")

def streamlit_app():
    """Streamlit app function for the SQL Agent."""
    import streamlit as st
    
    st.title("ReactSQLAgent - SQL Generator")
    st.write("Generate DDL, DML, or DCL SQL statements from business requirements")
    
    # Initialize session state
    if 'sql_agent' not in st.session_state:
        try:
            st.session_state.sql_agent = ReactSQLAgent()
            st.success("SQL Agent initialized successfully!")
        except Exception as e:
            st.error(f"Failed to initialize SQL Agent: {str(e)}")
            st.stop()
    
    # Input form
    with st.form("sql_generator_form"):
        requirement = st.text_area(
            "Enter your business requirement:",
            placeholder="e.g., Create an employee table with id, name, and salary",
            height=100
        )
        submitted = st.form_submit_button("Generate SQL")
    
    if submitted and requirement:
        with st.spinner("Processing your request..."):
            result = st.session_state.sql_agent.run(requirement)
            
            if isinstance(result, dict):
                if "output" in result:
                    st.subheader("Generated SQL:")
                    st.code(result["output"], language="sql")
                    
                if "error" in result and result["error"]:
                    st.error(f"Error: {result['error']}")
                    
                if "intermediate_steps" in result:
                    with st.expander("Show intermediate steps"):
                        for i, step in enumerate(result["intermediate_steps"]):
                            st.write(f"Step {i+1}: {step}")
            else:
                st.code(str(result), language="sql")
    
    elif submitted:
        st.warning("Please enter a business requirement.")

if __name__ == '__main__':
    # Check if running in Streamlit
    try:
        import streamlit as st
        # If streamlit is available and we're in a streamlit context
        if hasattr(st, 'session_state'):
            streamlit_app()
        else:
            # Uncomment the line below to run a quick test
            # test_agent()
            main()
    except ImportError:
        # Streamlit not available, run normal CLI
        # Uncomment the line below to run a quick test
        # test_agent()
        main()